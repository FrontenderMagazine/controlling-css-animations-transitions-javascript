# Контроль над анимациями и переходами CSS с помощью JavaScript

Некоторые веб-разработчики считают что создать анимацию на CSS сложнее чем на 
JavaScript. Хоть у CSS и есть некоторые ограничения, на самом деле в большинстве 
случаев он намного могущественнее чем мы думаем! К тому же он и более 
производительный чем принято считать. 

 На основе анимаций и переходов CSS в сочетании с каплей JavaScript можно 
 получить более эффективные аппаратно-ускоренные взаимодействия и анимацию, чем 
 на основе большинства библиотек JavaScript.

Перейдем сразу к делу.

## Небольшое примечание: между анимацией и переходами есть разница

[Переходы][1] в CSS применяются к элементу, при этом если свойство изменяется, 
то это должно происходить постепенно на протяжении определённого отрезка времени. 
С [анимациями][2] всё немного по-другому. Когда они применены, они просто 
проигрываются и выполняют свою задачу. Они дают более точный контроль над 
происходящим благодаря возможности управлять отдельными этапами анимации. 

В этой статье мы рассмотрим их отдельно.

## Управление CSS-переходами 

На форумах по программированию часто задают вопросы о том как можно запустить 
или приостановить переход для элемента. Вообще то, с применением JavaScript 
решение очень простое. 

Чтобы запустить переход для элемента, переключите класс для этого элемента на 
тот, который запускает переход.

Чтобы приостановить переход для элемента, используйте [`getComputedStyle`][3] и 
`getPropertyValue` в той точке перехода, в которой вы хотите его приостановить. 
Затем установите свойства CSS для этого элемента, равными тем, которые вы только 
что получили. 

Вот пример применения такого подхода:

<iframe id="cp_embed_GokAm" src="http://codepen.io/Zeaklous/embed/GokAm?safe=true&amp;default-tab=result&amp;user=Zeaklous&amp;slug-hash=GokAm&amp;theme-id=1&amp;height=450&amp;animations=run" allowtransparency="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;" frameborder="0" height="450" scrolling="no"></iframe>

Этот приём можно немного усложнить. В следующем примере переход также 
запускается посредством изменения названия класса, но в этом случае переменная 
фиксирует текущую степень масштабирования. 

<iframe id="cp_embed_FIlHe" src="http://codepen.io/Zeaklous/embed/FIlHe?safe=true&amp;default-tab=result&amp;user=Zeaklous&amp;slug-hash=FIlHe&amp;theme-id=1&amp;height=650&amp;animations=run" allowtransparency="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;" frameborder="0" height="650" scrolling="no"></iframe>

Обратите внимание, что в этот раз мы изменяем свойство `background-size`. 
[Переходы и анимацию можно применить][4] ко многим свойствам CSS, как правило, 
принимающим цифровые или цветовые значения. Родни Рем (Rodney Rehm) написал 
очень полезную и информативную статью о CSS-переходах, [которую можно найти 
здесь][5]. 

## Использование «функций обратного вызова» CSS

Наиболее полезные, хоть и не очень известные средства JavaScript для управления 
CSS переходами и анимацией — события `transitionEnd`, `transitionStart`, и 
`transitionIteration` (и их эквиваленты для анимаций). Вы возможно уже 
догадались что они делают. Эти события срабатывают когда переход для элемента 
заканчивается, начинается или проходит один цикл, соответственно. 

На данный момент для этих событий нужно прописывать вендорные префиксы, так что 
в этом демо мы используем созданную Крейгом Баклером (Craig Buckler) функцию 
`PrefixedEvent`, которая содержит параметры `element`, `type`, и `callback` 
чтобы сделать эти события кросс-браузерными. Вот его полезная [статья о 
перехвате CSS-анимации с помощью JavaScript][6]. А вот [ещё одна][7] о том как 
определить для какой анимации срабатывает событие. 

Согласно задумке этого примера, при наведении сердце должно увеличиться и 
анимация должна быть остановлена. 

<iframe id="cp_embed_rmDdx" src="http://codepen.io/Zeaklous/embed/rmDdx?safe=true&amp;default-tab=result&amp;user=Zeaklous&amp;slug-hash=rmDdx&amp;theme-id=1&amp;height=410&amp;animations=run" allowtransparency="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;" frameborder="0" height="410" scrolling="no"></iframe>

В версии на чистом CSS заметно подёргивание. Если только вы не навели курсор в 
самый подходящий момент, сердце рывком переходит в определённое состояние перед 
тем, как увеличиться до конечного состояния, прописанного для наведения. Версия 
с JavaScript намного плавнее. Лишнее подёргивание предотвращено тем, что 
анимация завершается перед переходом в новое состояние. 

## Управление CSS-анимацией

Как мы только что узнали, можно отслеживать элементы и реагировать на события 
анимации `animationStart`, `animationIteration`, и `animationEnd`. Однако что 
делать если нужно изменить анимацию в процессе её воспроизведения? Для этого нам 
понадобятся несколько хитростей.

### Свойство `animation-play-state`

Когда нужно приостановить анимацию, чтобы при необходимости продолжить её 
воспроизведение позже, необычайно полезным является CSS-свойство 
[`animation-play-state`][8]. Используя JavaScript, можно изменить CSS таким 
образом (помните о префиксах):

    element.style.webkitAnimationPlayState = "paused";
    element.style.webkitAnimationPlayState = "running";

Однако, когда CSS-анимация приостановлена с помощью `animation-play-state`, 
трансформации элемента так же не возможны, как и в процессе её воспроизведения. 
Нельзя приостановить анимацию, применить трансформацию, опять её запустить и 
ожидать что её воспроизведение плавно продолжится с нового изменённого состояния. 
Чтобы так сделать, нужно ещё немного углубиться в код.

### Получение текущего ключевого значения в процентах

К сожалению, на данный момент определить точное значение текущего выполнения 
анимации в процентах нельзя. Наилучший способ получить приблизительное значение — 
использовать функцию `setInterval`, которая будет выполняться 100 раз на 
протяжении выполнения анимации, то есть по сути мы получаем продолжительность 
анимации в мс/100. Например, если продолжительность анимации составляет 4 
секунды, `setInterval` будет выполняться каждые 40 миллисекунд (4000/100).

    var showPercent = window.setInterval(function() {
      if (currentPercent < 100) {
        currentPercent += 1;
      } else {
        currentPercent = 0;
      }
      // Обновляет div-блок, в котором отображается текущее процентное значение
      result.innerHTML = currentPercent;
    }, 40);

Этот подход далёк от идеального, так как в реальности функция выполняется реже 
чем каждые 40 миллисекунд. Думаю для большей точности лучше установить интервал 
в 39 миллисекунд, но полагаться на это вряд ли стоит, ведь скорее всего в 
зависимости от браузера результат будет отличаться и ни в одном из них не будет 
абсолютно точным. 

### Вычисление текущих значений свойств CSS-анимации

В идеальном мире мы могли бы выбрать элемент, для которого применена 
CSS-анимация, удалить эту анимацию и назначить новую. Воспроизведение новой 
анимации началось бы с текущего состояния. Мы живём в неидеальном мире и всё 
немного сложнее. 

Ниже представлено демо для тестирования приёма вычисления и изменения, так 
сказать, «промежуточного потока» CSS-анимации. При воспроизведении анимации 
элемент движется по круговой траектории с начальной позицией в верхней части по 
центру («на двенадцать часов»). При нажатии кнопки начальная позиция анимации 
меняется на текущую позицию элемента. Он продолжает движение по той же 
траектории, однако теперь это движение «начинается» из точки, в который элемент 
был во время нажатия кнопки. Об изменении исходной точки, и следовательно 
изменении анимации, свидетельствует изменение цвета элемента на красный в первом 
ключевом кадре. 

<iframe id="cp_embed_GwBJa" src="http://codepen.io/Zeaklous/embed/GwBJa?safe=true&amp;default-tab=result&amp;user=Zeaklous&amp;slug-hash=GwBJa&amp;theme-id=1&amp;height=430&amp;animations=run" allowtransparency="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;" frameborder="0" height="430" scrolling="no"></iframe>

Чтобы такое сделать нужно довольно сильно углубиться в код. Придётся покопаться 
в таблице стилей, чтобы найти исходную анимацию.

До таблицы стилей, привязанной к данной странице, можно добраться используя 
`document.styleSheets` и произвести итерацию с помощью оператора цикла `for`. 
Дальше показано как с помощью JavaScript можно найти конкретные значения 
анимации в объекте `CSSKeyFrameRules`:

    function findKeyframesRule(rule) {
      var ss = document.styleSheets;
      for (var i = 0; i < ss.length; ++i) {
        for (var j = 0; j < ss[i].cssRules.length; ++j) {
          if (ss[i].cssRules[j].type == window.CSSRule.WEBKIT_KEYFRAMES_RULE && 
          ss[i].cssRules[j].name == rule) { 
            return ss[i].cssRules[j]; }
        }
      }
      return null;
    }

После вызова функции в примере выше (т.е. `var keyframes = findKeyframesRule(anim)`), 
можно определить длительность анимации объекта (общее количество ключевых кадров 
в анимации) используя `keyframes.cssRules.length`. Затем нужно удалить «%» у 
каждого ключевого кадра чтобы они стали просто числами и JavaScript мог 
использовать их как числа. Чтобы это сделать, используем метод [`.map`][9].

    // Создание массива текущих процентных значений 
    // в анимации
    var keyframeString = [];  
    for(var i = 0; i < length; i ++)
    {
      keyframeString.push(keyframes[i].keyText); 
    }
  
    // Удаление всех % из массива чтобы
    // функция getClosest могла производить вычисления
    var keys = keyframeString.map(function(str) {
      return str.replace('%', '');
    });

На этом этапе `keys` являются массивом всех ключевых кадров анимации в числовом 
формате.

### Изменяем саму анимацию (наконец-то!)

Для демо с круговой анимацией потребовались две переменные: одна чтобы 
отслеживать на сколько градусов объект удалился от последней пройденной 
начальной точки и вторая для того, чтобы отслеживать на сколько градусов он 
удалился от первой точки начала анимации. Первую переменную можно изменить с 
помощью функции `setInterval` (на основе прошедшего времени и количества 
градусов в круге). Затем, используя следующий код, можно обновить вторую 
переменную при нажатии кнопки.

    totalCurrentPercent += currentPercent;
    // Поскольку это процентное значение, оно не может превышать 100
    if (totalCurrentPercent > 100) {
      totalCurrentPercent -= 100;
    }

Теперь можно использовать следующую функцию, чтобы определить какой ключевой 
кадр анимации является ближайшим к текущему процентному значению, исходя из 
массива возможных процентных значений ключевых кадров, который мы получили выше. 

    function getClosest(keyframe) {
      // curr обозначает текущий ключевой кадр
      var curr = keyframe[0];
      var diff = Math.abs (totalCurrentPercent — curr);
      for (var val = 0, j = keyframe.length; val < j; val++) {
        var newdiff = Math.abs(totalCurrentPercent — keyframe[val]);
        // Если разница между текущим процентным значением и  
        // ключевым кадром меньше, нужно взять новую разницу и ключевой кадр 
        if (newdiff < diff) {
          diff = newdiff;
          curr = keyframe[val];
         }
      }
      return curr;
    }

Чтобы получить новое значение первого ключевого кадра для дальнейшего 
использования в исчислениях, можно использовать метод [`.indexOf`][10]. Затем мы 
удаляем исходные ключевые кадры чтобы воссоздать новые.

    for (var i = 0, j = keyframeString.length; i < j; i ++) {
      keyframes.deleteRule(keyframeString[i]);
    }

Затем нужно изменить % в градусы круга. Это можно сделать просто умножив новое 
первое процентное значение на 3,6 (так как 100* 3.6 = 360). 

И наконец, мы создаем новые правила на основе полученных выше переменных. 
Разницу в 45 градусов между правилами можно объяснить тем, что у нас есть 8 
разных ключевых кадров, которые расположены по кругу. 360 (градусов в круге) 
поделить на 8, получаем 45. 

    // Добавляем нужный префикс 

    keyframes.insertRule("0% { 
      -webkit-transform: translate(100px,100px) rotate(" + (multiplier + 0) + "deg) 
                         translate(-100px,-100px) rotate(" + (multiplier + 0) + "deg);
      background-color:red; 
    }");
    keyframes.insertRule("13% { 
      -webkit-transform: translate(100px,100px) rotate(" + (multiplier + 45) + "deg)
                         translate(-100px,-100px) rotate(" + (multiplier + 45) + "deg); 
    }");
    …продолжение…

Затем мы обнуляем текущее процентное значение `setInterval`, чтобы она могла 
быть запущена снова. Обратите внимание, что в коде выше добавлен префикс для 
WebKit. Для большей кросс-браузерности вам наверное потребуется провести 
проверку с целью определения какие еще префиксы потребуются:

    // Получаем префикс для браузера 
    var browserPrefix;
    navigator.sayswho= (function(){
      var N = navigator.appName, ua = navigator.userAgent, tem;
      var M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
      if(M && (tem = ua.match(/version\/([\.\d]+)/i))!= null) M[2] = tem[1];
      M = M? [M[1], M[2]]: [N, navigator.appVersion,'-?'];
      M = M[0];
      if(M == "Chrome") { browserPrefix = "webkit"; }
      if(M == "Firefox") { browserPrefix = "moz"; }
      if(M == "Safari") { browserPrefix = "webkit"; }
      if(M == "MSIE") { browserPrefix = "ms"; }
    })();

Если вы хотели бы продолжить исследование, вам помогут ответ Рассела Урести 
(Russell Uresti) на [этот пост на StackOverflow][11] и [соответствующий пример][12]. 

## Превращение анимации в переход

Как видите, управлять переходами CSS с помощью JavaScript проще. Если используя 
анимации CSS вы не получили желаемых результатов, можете превратить её в переход 
и продолжить работу с ним. Уровень сложности написания кода для переходов и 
анимации приблизительно одинаков, однако переходы проще настроить и 
редактировать. 

Наибольшей проблемой при превращении CSS-анимаций в переходы является 
превращение `animation-iteration` в команду-эквивалент для `transition`. У 
переходов нет прямого эквивалента для этой команды, этим они главным образом и 
отличаются. 

В случае с нашим демо с круговым движением, можно использовать трюк с умножением 
`transition-duration` и `rotation` на `x`. В таком случае нужно применить класс 
для запуска анимации, ведь если присвоить изменённые свойства напрямую элементу, 
переход не будет осуществлён. Чтобы запустить переход (ложную анимацию), нужно 
присвоить класс для элемента.

В нашем примере это происходит при загрузке страницы:

<iframe id="cp_embed_IdlHx" src="http://codepen.io/Zeaklous/embed/IdlHx?safe=true&amp;default-tab=result&amp;user=Zeaklous&amp;slug-hash=IdlHx&amp;theme-id=1&amp;height=395&amp;animations=run" allowtransparency="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;" frameborder="0" height="395" scrolling="no"></iframe>

### Управление матрицами в CSS

Управлять CSS-анимациями можно с помощью `CSSMatrix`. Например:

    var translated3D = 
      new WebKitCSSMatrix(window.getComputedStyle(elem, null).webkitTransform);

Однако этот процесс может показаться очень запутанным, особенно тем, кто только 
начинает использовать анимации CSS. 

Больше информации о CSS-матрицах можно найти в [документации][13] (хотя нужно 
признать что пользы от неё не много), также посмотрите на [это приспособление][14], 
которое позволяет экспериментировать со значениями матрицы и почитайте статьи на 
эту тему, [например вот эту][15]. 

### Перезапуск анимации в CSS

Правильный способ перезапуска анимации описан [здесь на сайте CSS Tricks][16]. 
Вкратце, хитрость в том, чтобы удалить класс, который запустил анимацию, 
каким-либо образом запустить для него пересчёт состояния и снова применить класс. 
Если другие способы не работают, можно просто вырезать элемент из страницы и 
затем вернуть его назад. 

## Шевелите мозгами

Обдумывание и планирование протекания перехода или анимации перед написанием 
кода — лучший способ свести возможные проблемы к минимуму и достичь желаемого 
эффекта. Такой подход работает даже лучше, чем использование Googlе для поиска 
возможных решений когда код уже написан. Приёмы и хитрости, описанные в этой 
статье не всегда могут оказаться лучшим вариантом создания анимации для вашего 
проекта. 

Вот маленький пример того, как можно решить проблему если довести до ума HTML и 
CSS, когда вы уже собирались обращаться к JavaScript.

Скажем, нам нужно чтобы графический объект вращался непрерывно и менял 
направление вращения при наведении курсора. Вспоминая то, что вы прочитали в 
этой статье, вам возможно захочется использовать событие `animationIteration` 
для изменения анимации. Однако более эффективным и производительным решением 
будет использовать CSS и дополнительный контейнер. 

Хитрость в том, что спираль вращается со скоростью `x` в одном направлении, а 
при наведении её родительский элемент начинает вращаться со скоростью `2x` в 
противоположном направлении (начиная с одинаковой исходной позиции). Двойное 
вращение в разные стороны создает новый эффект вращения спирали в 
противоположном направлении. 

<iframe id="cp_embed_sFnyD" src="http://codepen.io/Zeaklous/embed/sFnyD?safe=true&amp;default-tab=result&amp;user=Zeaklous&amp;slug-hash=sFnyD&amp;theme-id=1&amp;height=300&amp;animations=run" allowtransparency="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;" frameborder="0" height="300" scrolling="no"></iframe>

Та же концепция была применена [в этом примере][17] в ответ на вопрос на 
StackOverflow.

## Ссылки!

Материалы по теме, которые могут вас заинтересовать:

* [Animo.js][18] — «Могущественный маленький инструмент для управления 
CSS-анимациями»
* [Хорошо что у нас есть спецификация!][19] — статья из журнала Smashing 
Magazine об особенностях переходов.

## В заключение

* `getComputedStyle` полезен при управлении CSS-переходами.
* `transitionEnd` и смежные события достаточно полезны при управлении 
CSS-переходами и анимацией с помощью JavaScript.
* Текущие значения анимации на CSS можно изменить, получив доступ к таблице 
стилей с помощью JavaScript, но это довольно сложно.
* Управлять CSS-переходами при помощи JavaScript проще чем CSS-анимациями.
* Работа с CSS-матрицами может быть довольно тягостной, особенно для новичков.
* Обдумывание задач проекта и планирование работы над ним — важные этапы 
написания кода для анимаций.

[1]: http://css-tricks.com/almanac/properties/t/transition/
[2]: http://css-tricks.com/almanac/properties/a/animation/
[3]: https://developer.mozilla.org/en-US/docs/Web/API/window.getComputedStyle
[4]: http://oli.jp/2010/css-animatable-properties/
[5]: http://coding.smashingmagazine.com/2013/04/26/css3-transitions-thank-god-specification/
[6]: http://www.sitepoint.com/css3-animation-javascript-event-handlers/
[7]: http://stackoverflow.com/questions/11619341/detect-which-animationend-has-fired-via-animationname
[8]: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state
[9]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
[10]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
[11]: http://stackoverflow.com/questions/10342494/set-webkit-keyframes-values-using-javascript-variable
[12]: http://jsfiddle.net/russelluresti/RHhBz/2/
[13]: https://developer.apple.com/library/safari/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instp/WebKitCSSMatrix/f
[14]: http://www.eleqtriq.com/wp-content/static/demos/2010/css3d/matrix3dexplorer.html
[15]: http://css-tricks.com/get-value-of-css-rotation-through-javascript/
[16]: http://css-tricks.com/restart-css-animation/
[17]: http://jsfiddle.net/vals/BseLV/
[18]: http://labs.bigroomstudios.com/libraries/animo-js
[19]: http://coding.smashingmagazine.com/2013/04/26/css3-transitions-thank-god-specification/